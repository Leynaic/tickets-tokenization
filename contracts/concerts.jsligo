#import "@ligo/fa/lib/fa2/nft/NFT.mligo" "NFT"

type storage = big_map<string, string>;
type concertParams = {
  name : string,
  tokenIds : set<nat>,
  tokenMetas : NFT.TokenMetadata.t
};

type parameter =
  | ["Main", concertParams]
  | ["Nothing"]
;

type return_ = [list <operation>, storage];

const initLedger = (acc: NFT.Ledger.t, elt: nat) : NFT.Ledger.t => Big_map.add(elt, Tezos.get_sender(), acc);


const createConcert = (params: concertParams, store: storage) : return_ => {
  const tokenIds: set<nat> = params.tokenIds;
  const legder: NFT.Ledger.t = Big_map.empty;
  const foldedLedger: NFT.Ledger.t = Set.fold(initLedger, tokenIds, legder);
  const tokenMetadata: NFT.TokenMetadata.t = params.tokenMetas;
  const operators: NFT.Operators.t = Big_map.empty;
  const metadata: NFT.Metadata.t = Big_map.empty;

  const initialConcertStorage: NFT.Storage.t = {
        ledger: foldedLedger,
        operators: operators,
        token_ids: tokenIds,
        token_metadata: tokenMetadata,
        metadata: metadata
    };
  
  let initialDelegate : option<key_hash> = (None() as option<key_hash>);
  let initialAmount : tez = 1 as tez;
  let createMyContract = (p: [option<key_hash>, tez,  NFT.Storage.t]) : [operation, address] =>
      (Michelson `{ 
            UNPAIR ;
            UNPAIR ;
            CREATE_CONTRACT 
            #include "@ligo/fa/compiled/fa2/nft/NFT_mligo.tz"
            ;
            PAIR }`
            as ((p: [option<key_hash>, tez, NFT.Storage.t]) => [operation, address]))(p)
   ;

  let originate : [operation, address] = createMyContract(initialDelegate, initialAmount, initialConcertStorage);

  return [list([originate[0]]), store];
};

const main = (action: parameter, store: storage): return_ => {
 return match(action, {
      Main: (params: concertParams) => createConcert(params, store),
      Nothing: () => [list([]), store]
 });
};